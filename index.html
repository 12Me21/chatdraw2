<!doctype html><html lang=en-QS><meta charset=utf-8><meta name=viewport content="width=device-width, height=device-height, initial-scale=1" id=$meta_viewport>
<title>CHATDRAW 2!!!</title>

<style>
	canvas {
		image-rendering: -moz-crisp-edges;
		image-rendering: pixelated;
		background: white;
	}
	#preview {
		width: 48px;
	}
	#canvas {
		width: 900px;
		cursor: crosshair;
		touch-action: none;
	}
	body, html {
		background: aliceblue;
		overflow: hidden;
	}
	label {
		display: contents;
	}
	form {
		display: flex;
		align-items: center;
		gap: 0.5rem;
	}
	form {
		flex-flow: wrap;
	}
</style>

<form autocomplete=off method=dialog id=$form style=max-width:100vw>
	<label>Brush:<input type=range min=0 max=1 value=0 name=brush style=width:50px></label>
	<label>Color:<input type=color name=color value="#AA3388"></label>
	<canvas width=16 height=16 id=preview></canvas>
	<label>Pattern:<input type=range min=0 max=15 value=5 name=pattern style=width:300px><div style=flex:none;width:50px></div></label>
</form>
<hr>
<canvas id=canvas width=300 height=300></canvas>
<img id=dither src=data:image/webp;base64,UklGRiIAAABXRUJQVlA4TBYAAAAvA8AAEDUgaNs2/FFv+0nEEf3PJiL5>


<script type=module>
	let ctx = canvas.getContext('2d')
	ctx.imageSmoothingEnabled = false    
	ctx.globalCompositeOperation = 'copy'
	
	let od = [0, 8, 2, 10, 12, 4, 14, 6, 3, 11, 1, 9, 15, 7, 13, 5]
	let patterns = []
	// temporary canvas
	let pcanvas = document.createElement('canvas')
	pcanvas.width = 4
	pcanvas.height = 4
	let p2d = pcanvas.getContext('2d')
	//
	for (let i=0; i<16; i++) {
		let data = new ImageData(4, 4)
		for (let x=0; x<16; x++)
			if (od[x] <= i)
				// just set the alpha to 255, leave R,G,B as 0 (black) since the color doesn't matter
				data.data[x<<2|3] = 0xFF
		
		p2d.putImageData(data, 0, 0)
		let pattern = ctx.createPattern(pcanvas, 'repeat')
		patterns.push(pattern)
	}
	
	let pc = preview.getContext('2d')
	
	let brushes = [
		new Path2D('M-100-100 m-1-1 h-1 v3 h1 v1 h3 v-1 h1 v-3 h-1 v-1 h-3 z'),
		new Path2D('M-100-100 m-5-5 v1 h-1 v2 h-1 v5 h1 v2 h1 v1 h1 v1 h2 v1 h5 v-1 h2 v-1 h1 v-1 h1 v-2 h1 v-5 h-1 v-2 h-1 v-1 h-1 v-1 h-2 v-1 h-5 v1 h-2 v1 z'),
	]
	
	await dither.decode()
	let pattern = ctx.createPattern(dither, "repeat")
	
		
	let COLOR = '#AA3388'
	let PATTERN = pattern
	let BRUSH = brushes[0]
	
	let aa = new Path2D()
	aa.rect(-100, -100, 16, 16)
	
	let draw=(ctx, x, y, brush=BRUSH, color=COLOR, pattern=PATTERN)=>{
		ctx.save()
		ctx.shadowColor = COLOR
		ctx.fillStyle = PATTERN
		x = ctx.shadowOffsetX = Math.floor(x)+100 
		y = ctx.shadowOffsetY = Math.floor(y)+100
		if (pattern.setTransform)
			pattern.setTransform(new DOMMatrix([1,0,0,1,-x,-y]))
		ctx.fill(brush)
		ctx.restore()
	}
	
	let brushes2 = []
for (let i=1; i<=7; i++) {
	let r = i/2
	let rs = r*r
	r += 0.5
	let p = new Path2D()
	for (let y=-r; y<=r; y++) {
		for (let x=-r; x<=r; x++) {
			if (x*x+y*y <= rs) {
				p.rect(Math.floor(r-1+x), Math.floor(r-1+y), Math.floor(-x*2)+1, 1)
				break
			}
		}
	}
	brushes2.push(p)
	}
	
	
	let pdraw=()=>{
		pc.clearRect(0, 0, 16, 16)
		draw(pc, 0, 0, aa, 'silver')
		draw(pc, 7, 7)
	}
	
	$form.color.oninput = ev=>{
		COLOR = $form.color.value
		pdraw()
	}
	$form.color.oninput()
	$form.pattern.oninput = ev=>{
		PATTERN = patterns[+$form.pattern.value]
		pdraw()
	}
	$form.pattern.oninput()
	$form.brush.oninput = ev=>{
		BRUSH = brushes[+$form.brush.value]
		pdraw()
	}
	$form.brush.oninput()
	
	let event_pos=(ev)=>{
		let rect = ev.target.getBoundingClientRect()
		let sx = rect.width / ev.target.width
		let sy = rect.height / ev.target.height
		return {
			x: (ev.offsetX + 0.5/(sx*window.devicePixelRatio)) / sx,
			y: (ev.offsetY + 0.5/(sy*window.devicePixelRatio)) / sy,
		}
	}
	
	let pointers = {}
	
	canvas.onpointerdown = ev=>{
		let p = event_pos(ev)
		draw(ctx, p.x, p.y)
		pointers[ev.pointerId] = p
		ev.target.setPointerCapture(ev.pointerId)
	}
	
	canvas.onlostpointercapture = ev=>{
		delete pointers[ev.pointerId]
	}
	
	canvas.onpointermove = ev=>{
		let p = pointers[ev.pointerId]
		if (!p)
			return
		let {x, y} = event_pos(ev)
		let dx = x-p.x
		let dy = y-p.y
		let dist = Math.hypot(dx,dy)
		p.x = x
		p.y = y
		for (let i=0;i<dist;i++) {
			draw(ctx, x, y)
			x -= dx/dist
			y -= dy/dist
		}
	}
	
	// aw why are we using ctx instead of c2d anymore..
	function draw_circle(ctx, cx, cy, radius1, radius2=radius1) {
		let rs1 = radius1 * radius1
		let rs2 = radius2 * radius2
		let rss = rs1 * rs2
		radius2 += 0.5
		radius1 += 0.5
		// todo: make this work better for non-integer locations?
		for (let y=-radius2; y<=radius2; y++) {
			for (let x=-radius1; x<=radius1; x++) {
				if (x*x*rs2+y*y*rs1 <= rss) {
					ctx.fillRect(Math.floor(cx+x), Math.floor(cy+y), Math.floor(-x*2)+1, 1)
					break
				}
			}
		}
	}
	BRUSH = brushes2[5]
	COLOR = 'orange'
/*	document.body.onclick = ev=>{
		let p
		p = performance.now()
		for (let i=0; i<1000;i++) {
			draw_circle(ctx, i, i+20, 3, 3)
		}
		console.log(performance.now()-p)
		ctx.shadowColor = COLOR
		ctx.fillStyle = PATTERN
		p = performance.now()
		for (let i=0; i<1000;i++) {
			draw(ctx, i, i)
		}
		console.log(performance.now()-p)
	}*/
</script>
